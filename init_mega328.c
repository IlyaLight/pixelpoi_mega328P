/*
 * init_mega328.c
 *
 * Created: 14.11.2016 12:25:24
 *  Author: Light
 */ 


#include "define.h"
#include "init_mega328.h"
#include <avr/io.h>

void init()
{


//Инициализация мк и периферии.

//#define F_CPU 8000000UL

#define SPI
#define	USART
#define TIMER0 

/*=========================================================================================

									Настройка PORTn				  
					  
=========================================================================================*/	

#if 1
/*
;=======================================================================
; ddr(x) - задает чем будет вывод:
; 1 - выход
; 0 - вход
;=======================================================================
; port(x) - включает подтяжку входа:
; 1 - подтяжка включена
; 0 - подтяжка выключена
; значение 0 так же устанавливает выход в 0 при включении мик-ра, если
; вывод сконфигурирован выходом, а 1 включает выход относительно минуса питания
;=======================================================================*/	


//PORTB
//
//        XTAL2/TOSC2/PCINT7		7-
//		  |XTAL1/TOSC1/PCINT6		6-
//		  ||SCK/PCINT5				5-nRF_SCK
//		  |||MISO/PCINT4			4-nRF_MISO
//		  ||||MOSI/OC2A/PCINT3		3-nRF_MOSI
//		  |||||SS/OC1B/PCINT2		2-nRF_CSN
//		  ||||||OC1A/PCINT1			1-
//		  |||||||ICP1/CLKO/PCINT0	0-
//		  76543210
DDRB =  0b11101111;
PORTB = 0b00010000;

//PORTC
//
//        NO
//		  |RESET/PCINT14			6-
//		  ||ADC5/SCL/PCINT13		5-
//		  |||ADC4/SDA/PCINT12		4-
//		  ||||ADC3/PCINT11			3-
//		  |||||ADC2/PCINT10			2-
//		  ||||||ADC1/PCINT9			1-nRF_CE
//		  |||||||ADC0/PCINT8		0-nRF_IRQ
//		  76543210
DDRC =  0b11111110;
PORTC = 0b00000001;

//PORTD
//
//        AIN1/PCINT23				7-	
//		  |AIN0/OC0A/PCINT22		6-Button1
//		  ||T1/OC0B/PCINT21			5-
//		  |||XCK/T0/PCINT20			4-
//		  ||||INT1/OC2B/PCINT19		3-
//		  |||||INT0/PCINT18			2-
//		  ||||||TXD/PCINT17			1-RS232
//		  |||||||RXD/PCINT16		0-RS232
//		  76543210
DDRD =  0b10111111;
PORTD = 0b01000000;	
#endif	
	
/*=========================================================================================

									Настройка SPI				  
					  
=========================================================================================*/	
#ifdef	SPI
	
SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
	
  /*SPIE - разрешение прерывания от SPI, 1-ON,0-OFF
	
	SPE  - вкл/выкл SPI,                 1-ON,0-OFF
	
	DORD - порядок передачи данных       1-байт передается с младшего бита, 0->7
										 0-байт передается со старшего бита.7->0
										 
	MSTR - Выбор режима (Master/Slave)   1-Master, 0-Slave
	
	CPOL - полярность тактового сигнала  0-импульсы положительной полярности
										 1-импульсы отрицательной полярности
										 
	CPHA - Фаза тактового сигнала        0-биты считываются по переднему фронту ноги SCK
										 1-биты считываются по заднему фронту ноги SCK
	SPR1 - Скорость передачи
	SPR0 - Скорость передачи
	
	SPI2X  SPR1  SPR0   Частота SCK
	  0     0     0		  F_CPU/4
	  0     0     1		  F_CPU/16
	  0     1     0		  F_CPU/64
	  0     1     1		  F_CPU/128
	  1     0     0		  F_CPU/2
	  1     0     1		  F_CPU/8
	  1     1     0		  F_CPU/32
	  1     1     1		  F_CPU/64
	*/
			          
SPSR = (0<<SPIF)|(0<<WCOL)|(0<<SPI2X);

 /*	SPIF  -	флаг прерывания от SPI. Он устанавливается в 1 по окончании передачи байта данных. 
			Если разрешены прерывания модуля, одновременно с установкой этого флага генерируется 
			прерывание от SPI. Также этот флаг устанавливается в 1 при переводе микроконтроллера 
			из режима master в режим slave с помощью вывода SS. Сброс флага происходит аппаратно, 
			при вызове подпрограммы обработки прерывания или после чтения регистра SPSR с 
			последующим обращением к регистру данных SPDR.
			
	WCOL  -	флаг конфликта записи. Флаг устанавливается в 1, если во время передачи данных 
			выполняется попытка записи в регистр данных SPDR. Флаг сбрасывается аппаратно после 
			чтения регистра SPSR с последующим обращением к регистру данных SPDR.
			
	SPI2X -	бит удвоения скорости обмена. Установка этого разряда в 1 удваивает частоту тактового 
			сигнала SCK. Микроконтроллер при этом должен работать в режиме master.
*/		

#endif
/*=========================================================================================

									Настройка USART				  
					  
=========================================================================================*/					  
#ifdef	USART

//UBRR0H = (unsigned char)(MYUBRR>>8);
//UBRR0L = 103;	//(unsigned char)MYUBRR;

#define	baudrate 9600L	//скорость передачи	
#define	MYUBRR  (F_CPU/(16*baudrate)-1)	  					  
#define HI(x) ((x)>>8)
#define LO(x) ((x)& 0xFF)				  
UBRR0L = LO(MYUBRR);
UBRR0H = HI(MYUBRR);			  		
//UBRR - 12-ти битный регистр контроллера скорости передачи 
//UDR  - отсюда забираем/отдаем результат	
			  
UCSR0A = (0<<RXC0)|(0<<TXC0)|(0<<UDRE0)|(0<<FE0)|(0<<DOR0)|(0<<UPE0)|(0<<U2X0)|(0<<MPCM0);
  /*RXC -	Флаг завершения приема. Флаг устанавливается в 1 при наличии  
			непрочитанных данных в буфере приемника (регистр данных UDR). Сбрасывается 
			флаг аппаратно после опустошения буфера. Если бит RXCIE0  
			регистра UCSR0B установлен, то при установке флага генерируется 
			запрос на прерывание «прием завершен» 
	TXC -	Флаг завершения передачи. Флаг устанавливается в 1 после передачи всех  
			битов посылки из сдвигового регистра передатчика при условии, что в регистр 
			данных UDR не было загружено новое значение. Если бит TXCIE0 
			регистра UCSR0B установлен, то при установке флага  
			генерируется прерывание «передача завершена». Флаг сбрасывается аппаратно при  
			выполнении подпрограммы обработки прерывания или программно, записью 
			в него лог. 1 
	UDRE - Флаг опустошения регистра данных. Данный флаг устанавливается в 1 
			при пустом буфере передатчика (после пересылки байта из регистра данных 
			UDR в сдвиговый регистр передатчика). Установленный флаг означает, 
			что в регистр данных можно загружать новое значение. Если бит UDRIE 
			регистра UCSR0B установлен, генерируется запрос на прерывание «регистр 
			данных пуст». Флаг сбрасывается аппаратно, при записи в регистр данных 
	FE -	Флаг ошибки кадрирования. Флаг устанавливается в 1 при обнаружении 
			ошибки кадрирования, т. е. если первый стоп-бит принятой посылки равен 0. 
			Флаг сбрасывается при приеме стоп-бита, равного 1 
	DOR -  Флаг переполнения. Флаг устанавливается в 1, если в момент обнаружения 
			нового старт-бита в сдвиговом регистре приемника находится последнее 
			принятое слово, а буфер приемника полон (содержит два байта). Флаг  
			сбрасывается при пересылке принятых данных из сдвигового регистра  
			приемника в буфер. 
	UPE -  Флаг ошибки контроля четности. Флаг устанавливается в 1, если в данных, 
			находящихся в буфере приемника, выявлена ошибка контроля четности. 
			При отключенном контроле четности этот бит постоянно сброшен в 0 
	U2X -  Удвоение скорости обмена. Если этот бит установлен в 1, то коэффициент 
			деления предделителя контроллера скорости передачи уменьшается с 16 до 
			8, удваивая тем самым скорость асинхронного обмена по  последовательному
			каналу. Этот бит используется только при асинхронном режиме работы 
			и в синхронном режиме должен быть сброшен 
	MPCM - Режим мультипроцессорного обмена. Если этот бит установлен в 1, ведомый 
			микроконтроллер ожидает приема кадра, содержащего адрес. Кадры, 
			не содержащие адреса устройства, игнорируются */

UCSR0B = (1<<RXCIE0)|(0<<TXCIE0)|(0<<UDRIE0)|(1<<RXEN0)|(1<<TXEN0)|(0<<UCSZ02)|(0<<RXB80)|(0<<TXB80);
  /*RXCIE - Разрешение прерывания по завершении приема. Если данный бит установлен 
			 в 1, то при установке флага RXC0 регистра UCSR0A  генерируется прерывание 
			 «прием завершен» (если флаг I регистра SREG установлен в1) 

	TXCIE - Разрешение прерывания по завершении передачи. Если данный бит установлен 
			 в 1, то при установке флага TXC регистра UCSRA генерируется прерывание 
			 «передача завершена» (если флаг 1 регистра SREG  установлен в 1) 

	UDRIE - Разрешение прерывания при очистке регистра данных UART. Если данный бит 
			 установлен в 1, то при установке флага UDRE  регистра UCSRA 
			 генерируется прерывание «регистр данных пуст» (если флаг I  
			 регистра SREG установлен в 1) 

	RXEN  - Разрешение приема. При установке этого бита в 1 разрешается работа  
			 приемника USART и переопределяется функционирование вывода RXD 
			 При сбросе бита RXEN0 работа приемника запрещается, а его буфер 
			 сбрасывается. Значения флагов ТХС0, DOR0 и FE0 при 
			 этом становятся недействительными 

	TXEN  - Разрешение передачи. При установке этого бита в 1 разрешается работа  
			 передатчика UART и переопределяется функционирование вывода TXD. 
			 Если бит сбрасывается в 0 во время передачи, то выключение передатчика 
			 произойдет только после завершения передачи данных, находящихся в  
			 сдвиговом регистре и буфере передатчика 

	UCSZ2 - Формат посылок. Этот бит совместно с битами UCSZ01:0 регистра UCSR0C 
			 используется для задания размера слов данных, передаваемых по 
			 последовательному каналу. 

	RXB8  - 8-й бит принимаемых данных. При использовании 9-битных слов данных этот 
             бит содержит значение старшего бита принятого слова. Содержимое этого 
			 бита должно быть считано до прочтения регистра данных UDR0. 

	TXB8  - 8-й бит передаваемых данных. При использовании 9-битных слов данных  
			 содержимое этого бита является старшим битом передаваемого слова.  
			 Требуемое значение должно быть занесено в этот бит до загрузки байта данных в  
			 регистр UDR0 */

UCSR0C = (0<<UMSEL01)|(0<<UMSEL00)|(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(1<<UCSZ01)|(1<<UCSZ00)|(0<<UCPOL0);

/*
Режим работы USART
-----------------------------------  
UMSEL01		UMSEL00  Режим работы USART
-----------------------------------
	0		0		Асинхронный USART
	0		1		Синхронный USART
	1		0		(Reserved)
	1		0		Master SPI (MSPIM)
-----------------------------------

Режим работы схемы контроля и формирования бита четности. 
-----------------------------------
UPM1	UPM0	Режим работы схемы
-----------------------------------
   0       0    Disabled
   0       1    Reserved
   1       0    Включена, проверка на четность  Even Parity
   1       1    Включена, проверка на нечетность  Odd Parity
-----------------------------------

Количество стоповых битов
-----------------------------------
USBS  Stop Bit(s)
 0      1-bit
 1      2-bit
-----------------------------------

Определение размера слова данных 
-----------------------------------
UCSZ2 UCSZ1 UCSZ0  Размер слова данных
-----------------------------------
   0      0      0    5-bit
   0      0      1    6-bit
   0      1      0    7-bit
   0      1      1    8-bit
   1      0      0    Reserved
   1      0      1    Reserved
   1      1      0    Reserved
   1      1      1    9-bit
-----------------------------------


UCPOL - Полярность тактового сигнала. Значение этого бита определяет момент  
		 выдачи и считывания данных на выводах модуля. Бит используется только при 
		 работе в синхронном режиме. При работе в асинхронном режиме он должен 
		 быть сброшен в 0. 
-------------------------------------------------------------------
UCPOL  Выдача данных на вывод TXD  Считывание данных с вывода RXD
-------------------------------------------------------------------
	0    Спадающий фронт ХСК         Нарастающий фронт ХСК 
	1	 Нарастающий фронт ХСК       Спадающий фронт ХСК
-------------------------------------------------------------------	
Обратите внимание на то, что в моделях ATmega8515x/8535x, 
ATmega8x/16x/32x и ATmegal62x регистр UBRRH размещается по тому же 
адресу, что и регистр управления UCSRC. Поэтому при обращении по 
этим адресам необходимо выполнить ряд дополнительных действий для 
выбора конкретного регистра. 
При записи регистр определяется состоянием старшего бита  
записываемого значения URSEL. Если этот бит сброшен в 0, изменяется  
содержимое регистра UBRRH. Если же старший бит значения установлен в 1,  
изменяется содержимое регистра управления UCSRC. Приведенные ниже 
фрагменты программ иллюстрируют сказанное: 
			Пример на ассемблере 
			; Записать 2 в UBRRH 
ldi г16,0х02 
out UBRRH,rl6 
			; Установить биты USBS и UCSZ1 регистра UCSRC 
ldi rl6(l«URSEL) I (A«USBS) I (A«UCSZ1) 
out UCSRC,rl6 

			Пример на Си 
			// Записать 2 в UBRRH  
UBRRH = 0x02; 
			// Установить биты USBS и UCSZ1 регистра UCSRC 
UCSRC = A«URSEL) I A«USBS) I A«UCSZ1) ; */

#endif

/*=========================================================================================

								Настройка Timer/Counter0 

=========================================================================================*/

#ifdef TIMER0

TCCR0A = (0 << COM0A0)|(0 << COM0B0)|(2 << WGM00);
/*
	COM0A1:0 -	Bits 7:6 Compare Match Output A Mode
				Режим работы блока сравнения. Эти разряды определяют поведение
				вывода OCnA при наступлении события «Совпадение». Влияние содер
				жимого этих разрядов на состояние вывода зависит от режима работы
				таймера/счетчика

Compare Output Mode, non-PWM Mode				
----------------------------------- 			
COMn1	COMn0	Описание
----------------------------------- 
0|	0		0	Таймер/счетчик Tn отключен от вывода OCnA
1|	0		1	Состояние вывода меняется на противоположное
2|	1		0	Вывод сбрасывается в «0»
3|	1		1	Вывод устанавливается в «1»
-----------------------------------  
	
Compare Output Mode, Fast PWM Mode
-----------------------------------
COMnA1	COMnA0	Описание
-----------------------------------
0|	0		0	Таймер/счетчик Tn отключен от вывода OCnA
1|	0		1	WGM02 = 0: Таймер/счетчик Tn отключен от вывода OCnA
				WGM02 = 1: Состояние вывода меняется на противоположное
2|	1		0	Сбрасывается в «0» при равенстве регистров TCNTn и OCRnA. Устанавли
				вается в «1» при TCNTn = $00 (неинвертированный ШИМсигнал)
3|	1		1	Устанавливается в «1» при равенстве регистров TCNTn и OCRn. Сбрасы
				вается в «0» при TCNTn = $00 (инвертированный ШИМсигнал)
-----------------------------------
Отдельно следует рассмотреть случаи, когда в регистре сравнения нахо
дятся предельно возможные значения ($00 и $FF). В первом случае, если со
держимое регистра сравнения OCR0A равно $00, на выходе OC0A
при каждом 256м такте сигнала clkT0 (clkT2) будут наблюдаться корот
кое выбросы. Если же содержимое регистра сравнения OCR0 (OCR2) равно
$FF, то вывод OC0 (OC2) переключится в устойчивое состояние, определяе
мое установками разрядов COMnA1:COMnA0

Compare Output Mode, Phase Correct PWM Mode
-----------------------------------
COMnA1	COMnA0	Описание
-----------------------------------
0|	0		0	Таймер/счетчик Tn отключен от вывода OCnA
1|	0		1	WGM02 = 0: Таймер/счетчик Tn отключен от вывода OCnA
				WGM02 = 1: Состояние вывода меняется на противоположное
2|	1		0	Сбрасывается в «0» при прямом счете и устанавливается в «1» при 
				обратном счете (неинвертированный ШИМсигнал)
3|	1		1	Устанавливается в «1» при прямом счете и сбрасывается в «0» при 
				обратном счете (инвертированный ШИМсигнал)
-----------------------------------


	COM0B1:0 -	Bits 5:4 Compare Match Output B Mode
				Режим работы блока сравнения. Эти разряды определяют поведение
				вывода OCnB при наступлении события «Совпадение». Влияние содер
				жимого этих разрядов на состояние вывода зависит от режима работы
				таймера/счетчика
				
Compare Output Mode, non-PWM Mode
-----------------------------------
COMnB1	COMnB0	Описание
-----------------------------------
аналогично COMnA1


Compare Output Mode, Fast PWM Mode
-----------------------------------
COMnB1	COMnB0	Описание
-----------------------------------
0|	0		0	Таймер/счетчик Tn отключен от вывода OCnA
1|	0		1	зарезервировано
2|	1		0	Сбрасывается в «0» при равенстве регистров TCNTn и OCRnA. Устанавли
				вается в «1» при TCNTn = $00 (неинвертированный ШИМсигнал)
3|	1		1	Устанавливается в «1» при равенстве регистров TCNTn и OCRn. Сбрасы
				вается в «0» при TCNTn = $00 (инвертированный ШИМсигнал)
-----------------------------------

Compare Output Mode, Phase Correct PWM Mode
-----------------------------------
COMnB1	COMnB0	Описание
-----------------------------------
0|	0		0	Таймер/счетчик Tn отключен от вывода OCnA
1|	0		1	зарезервировано
2|	1		0	Сбрасывается в «0» при прямом счете и устанавливается в «1» при
				обратном счете (неинвертированный ШИМсигнал)
3|	1		1	Устанавливается в «1» при прямом счете и сбрасывается в «0» при
				обратном счете (инвертированный ШИМсигнал)
-----------------------------------

				
	WGM01:0 -	Bits 1:0 Waveform Generation Mode
				Режим работы таймера/счетчика
				

---------------------------------------------------------------------
WGM02	WGM01	WGM00	TOP		Update_OCRx TOV_FlagSet	Mode
---------------------------------------------------------------------
0|	0		0		0	0xFF	Immediate	MAX			 нормальный
														Самый простой режим работы Нормальный режим. В этом режиме 
														счетчик увеличивается. Счетчик после достиженя 0xFF перолняется
														в 0x00. Флаг флаг перполния TOV0 в этом случае	ведет себя как 
														девятый бит, за исключением того, что он только установить, 
														не обнуляется.
1|	0		0		1	0xFF	TOP			BOTTOM		 PWM Phase Correct ШИМ с точной фазой.	
														Счетчик считает сначала от 0 до 255, потом от 255 до 0. Вывод OCxx
														при первом совпадении сбрасывается, при втором устанавливается.
														Но частота ШИМ при этом падает вдвое, изза большего периода.
														Основное его предназначение, делать многофазные ШИМ сигналы,
														например, трехфазную синусоиду. Чтобы при изменении скважности
														не сбивался угол фазового сдвига между двумя ШИМ сигналами. Т.е.
														центры импульсов в разных каналах и на разной скважности будут совпадать.
2|	0		1		0	OCRA	Immediate	MAX			 CTC Clear Timer On Compare Сброс при сравнении
														В этом режиме счетный регистр тоже функционирует как обычный сум
														мирующий счетчик, инкремент которого осуществляется по каждому им
														пульсу тактового сигнала. Однако максимально возможное зна
														чение счетного регистра и, следовательно, разрешающая способность
														счетчика определяется регистром сравнения OCRnA
3|	0		1		1	0xFF	BOTTOM		MAX			 Fast PWM Быстродействующий ШИМ
														Счетный регистр в этом режиме функционирует как суммирующий
														счетчик, инкремент которого осуществляется по каждому импульсу такто
														вого сигнала. Состояние счетчика изменяется от $00 до $FF, по
														сле чего счетный регистр сбрасывается и цикл повторяется. При достиже
														нии счетчиком максимального значения устанавливается флаг прерывания
														TOVnA регистра TIFR. При равенстве содержимого счетного регистра
														и регистра сравнения устанавливается флаг OCFnA регистра TIFR.
0|	1		0		0									 зарезервировано
1|	1		0		1	OCRA	TOP			BOTTOM		 PWM Phase Correct
2|	1		1		0									 зарезервировано
4|	1		1		1	OCRA	BOTTOM		TOP			 Fast PWM
---------------------------------------------------------------------				
*/

TCCR0B = (0 << FOC0A)|(0 << FOC0B)|(0 << WGM02)|(4 << CS00);
/*	FOC0A, FOC0B -	Функция бита FOC0 активна только, если с помощью бит WGM задан один из 
					режимов, где нет широтно-импульсной модуляции. Однако в целях 
					совместимости с последующими микроконтроллерами рекомендуется во время
					записи в регистр TCCR0 в позиции данного бита указывать лог. 0, если
					таймер работает в одном из режимов с широтно-импульсной модуляцией. Если
					записать лог. 1 в бит FOC0, то это приводит к принудительной установке
					результата сравнения на входе блока формирования выходного сигнала. 
					Выход OC0 изменяется в соответствии с установками бит COM01, COM00. 
					Следовательно, значение записанное в COM01, COM00 определяет эффект 
					действия принудительной установки результата сравнения. Обратите также 
					внимание, что бит FOC0 является стробирующим. Строб FOC0 не генерирует
					каких-либо прерываний, а также не вызывает сброс таймера в режиме СТС,
					где регистр OCR0 задает верхний предел счета.Бит FOC0 всегда считывается 
					как 0.

	WGM02 -	работает в связке с битами WGM01:0 и регистра TCCR0A
	
	CS02:0 -	Bits 2:0 Clock Select
-----------------------------------	
CS02	CS01	CS00	Description
-----------------------------------
0| 0	   0	   0	No clock source (Timer/Counter stopped)
1| 0	   0	   1	clk/(No prescaling)
2| 0	   1	   0	clk/8 (From prescaler)
3| 0	   1	   1	clk/64 (From prescaler)
4| 1	   0	   0	clk/256 (From prescaler)
5| 1	   0	   1	clk/1024 (From prescaler)
6| 1	   1	   0	внешний источник на выводе T0  по спаду сигнала
7| 1	   1	   1	внешний источник на выводе T0  по возрастанию сигнала
-----------------------------------	

*/

TCNT0 = 0;
/*Timer/Counter Register
 Это 8-ми разрядный счетный регистр. Когда таймер работает, по каждому импульсу тактового 
 сигнала значение TCNT0 изменяется на единицу. В зависимости от режима работы таймера, 
 счетный регистр может или увеличиваться, или уменьшаться. Регистр TCNT0 можно как читать, 
 так и записывать. Последнее используется когда требуется задать его начальное значение. 
 Когда таймер работает, изменять его содержимое TCNT0 не рекомендуется, так как это 
 блокирует схему сравнения на один такт.

*/

OCR0A = 125;
/*Output Compare Register A
 Это 8-ми разрядный регистр сравнения. Его значение постоянно сравнивается со счетным 
 регистром TCNT0, и в случае совпадения таймер может выполнять какие-то действия - вызывать 
 прерывание, менять состояние вывода OC0A и т.д. в зависимости от режима работы.
 Значение OCR0 можно как читать, так и записывать.
*/

//OCR0B = 0;
/* Output Compare Register B
Это 8-ми разрядный регистр сравнения. Его значение постоянно сравнивается со счетным
регистром TCNT0, и в случае совпадения таймер может выполнять какие-то действия - вызывать
прерывание, менять состояние вывода OC0B и т.д. в зависимости от режима работы.
Значение OCR0 можно как читать, так и записывать.
*/

TIMSK0 = (0 << OCIE0B)|(1 << OCIE0A)|(0 << TOIE0);
/*	OCIE0B -	разрешает прерыванин по совподению с OCRnB
	OCIE0A -	разрешает прерыванин по совподению с OCRnA
	TOIE0 -		разрешает перерывание по переполненю счетчика  
*/

//TIFR0 = (1 << OCF0B)|(1 << OCF0A)|(1 << TOV0);
/*	OCF0B -	устанавливается в 1 при совпадении счетного регистра с регистром сравнения
	OCF0A - устанавливается в 1 при совпадении счетного регистра с регистром сравнения
	TOV0  -	устанавливается в 1 при переполнении счетного регистра.

 Флаги автоматически очищаются при запуске обработчика прерывания. Также это можно сделать 
 программно, записав 1 в соответствующий флаг. 
*/
#endif
}